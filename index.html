<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>American Manufacturing 2026</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg">
    <link rel="icon" type="image/png" href="images/favicon.png">
    <script>
        // Set grid dimensions as CSS variables before page renders
        // Define as global constants for use throughout the app
        window.TILE_SIZE = 40;
        window.GRID_W = 35;
        window.GRID_H = 32;
        document.documentElement.style.setProperty('--tile-size', TILE_SIZE);
        document.documentElement.style.setProperty('--grid-w', GRID_W);
        document.documentElement.style.setProperty('--grid-h', GRID_H);
    </script>
    <style>
        :root {
            --bg-color: #1a2634;
            --panel-bg: #2b2b2b;
            --led-green: #39ff14;
            --led-red: #ff0000;
            --gold: #ffd700;
            --usa-red: #B22234;
            --usa-blue: #3C3B6E;
            --usa-white: #FFFFFF;
            --industrial-steel: #71797E;
            --industrial-orange: #FF6600;
            --paper-white: #e0e0e0;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            height: 100vh;
        }

        /* --- Mobile Blocker --- */
        #mobile-warning {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 20000;
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 40px;
            box-sizing: border-box;
        }
        #mobile-warning > div {
            background: #1a2634;
            border: 4px solid var(--usa-red);
            border-radius: 8px;
            padding: 30px;
            max-width: 450px;
            box-shadow: 0 0 30px var(--usa-red);
        }
        #mobile-warning p { color: #ccc; font-size: 14px; line-height: 1.6; }
        .mobile-warning-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--gold);
            margin-bottom: 15px;
        }
        #mobile-warning p.mobile-warning-footer {
            margin-top: 20px;
            color: #888;
        }

        @media (max-width: 1050px), (max-height: 700px) {
            #mobile-warning { display: flex; }
            #game-wrapper, #stats-sidebar, .sparks, #modal-overlay { display: none !important; }
        }

        /* --- Fireworks Canvas --- */
        .sparks {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
        }
        #fireworksCanvas {
            width: 100%;
            height: 100%;
        }

        .sparks::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(3px 3px at 100px 50px, var(--industrial-orange), transparent),
                radial-gradient(4px 4px at 200px 150px, #FFD700, transparent),
                radial-gradient(2px 2px at 300px 250px, var(--industrial-orange), transparent),
                radial-gradient(3px 3px at 400px 100px, #FFA500, transparent);
            background-size: 550px 550px;
            animation: sparksAnim 8s linear infinite;
            opacity: 0.4;
            z-index: 1;
        }

        @keyframes sparksAnim {
            100% { transform: translateY(550px); }
        }

        /* --- Layout --- */
        #game-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #111;
            position: relative;
            overflow: auto;
        }

        /* Patriotic Border Container */
        #game-frame {
            position: relative;
            border: 12px solid var(--usa-blue);
            border-image: repeating-linear-gradient(45deg, var(--usa-red), var(--usa-red) 10px, var(--usa-white) 10px, var(--usa-white) 20px, var(--usa-blue) 20px, var(--usa-blue) 30px) 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            margin: 10px 0;
            flex-shrink: 0;
        }

        @keyframes flagWave {
            0%, 100% {
                transform: translateX(-50%) rotateY(0deg) skewY(0deg);
            }
            25% {
                transform: translateX(-50%) rotateY(-8deg) skewY(2deg);
            }
            75% {
                transform: translateX(-50%) rotateY(8deg) skewY(-2deg);
            }
        }

        #game-frame::before {
            content: '';
            width: 60px;
            height: 40px;
            background-image: url('american_flag.svg');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5));
            transform-style: preserve-3d;
            animation: flagWave 3s ease-in-out infinite;
        }

        /* Year Badges */
        @keyframes colorCycle {
            0%, 22% {
                border-color: var(--usa-red);
                background: var(--usa-blue);
                color: var(--usa-white);
                box-shadow: 0 0 15px var(--usa-red);
            }
            33%, 55% {
                border-color: var(--usa-blue);
                background: var(--usa-white);
                color: var(--usa-blue);
                box-shadow: 0 0 15px var(--usa-blue);
            }
            66%, 89% {
                border-color: var(--usa-red);
                background: var(--usa-white);
                color: var(--usa-blue);
                box-shadow: 0 0 15px var(--usa-red);
            }
            100% {
                border-color: var(--usa-red);
                background: var(--usa-blue);
                color: var(--usa-white);
                box-shadow: 0 0 15px var(--usa-red);
            }
        }

        .year-badge {
            position: absolute;
            top: calc(var(--tile-size) * -0.5px);
            width: calc(var(--tile-size) * 1.5px);
            height: calc(var(--tile-size) * 1.5px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            border: 3px solid var(--usa-red);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--usa-red);
            z-index: 20;
            font-family: 'Courier New', monospace;
        }
        .year-badge-left {
            left: calc(var(--tile-size) * -1px);
            animation: yearColorSwitchReverse 12s ease-in-out infinite;
        }
        .year-badge-right {
            right: calc(var(--tile-size) * -1px);
            animation: yearColorSwitch 12s ease-in-out infinite;
        }

        .logo-badge {
            position: absolute;
            bottom: calc(var(--tile-size) * -0.5px);
            width: calc(var(--tile-size) * 1.5px);
            height: calc(var(--tile-size) * 1.5px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border: 3px solid var(--usa-blue);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--usa-blue);
            z-index: 20;
            overflow: hidden;
        }
        .logo-badge-left {
            left: calc(var(--tile-size) * -1px);
        }
        .logo-badge-right {
            right: calc(var(--tile-size) * -1px);
        }
        .logo-badge img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }
        .logo-badge img:first-child {
            animation: logoFade 12s ease-in-out infinite;
        }
        .logo-badge img:last-child {
            animation: logoFadeReverse 12s ease-in-out infinite;
        }

        @keyframes logoFade {
            0%, 20% { opacity: 1; }
            30%, 70% { opacity: 0; }
            80%, 100% { opacity: 1; }
        }
        @keyframes logoFadeReverse {
            0%, 20% { opacity: 0; }
            30%, 70% { opacity: 1; }
            80%, 100% { opacity: 0; }
        }
        @keyframes yearColorSwitch {
            0%, 20% {
                background: var(--usa-blue);
                color: var(--usa-white);
            }
            30%, 70% {
                background: var(--usa-white);
                color: var(--usa-blue);
            }
            80%, 100% {
                background: var(--usa-blue);
                color: var(--usa-white);
            }
        }
        @keyframes yearColorSwitchReverse {
            0%, 20% {
                background: var(--usa-white);
                color: var(--usa-blue);
            }
            30%, 70% {
                background: var(--usa-blue);
                color: var(--usa-white);
            }
            80%, 100% {
                background: var(--usa-white);
                color: var(--usa-blue);
            }
        }

        #game-container {
            width: calc(var(--tile-size) * var(--grid-w) * 1px);
            height: calc(var(--tile-size) * var(--grid-h) * 1px);
            cursor: crosshair;
            overflow: hidden;
            background: #1e2430;
            position: relative;
        }
        canvas { display: block; }

        /* --- Sidebar --- */
        #stats-sidebar {
            width: 300px; 
            background: linear-gradient(180deg, #333 0%, #222 100%);
            border-left: 4px solid #444;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            z-index: 10;
            overflow-y: auto; 
        }

        .panel-header {
            background: repeating-linear-gradient(45deg, var(--usa-red), var(--usa-red) 10px, var(--usa-white) 10px, var(--usa-white) 20px, var(--usa-blue) 20px, var(--usa-blue) 30px);
            padding: 4px; margin-bottom: 10px; text-align: center; border: 2px solid #000; flex-shrink: 0;
        }
        h1 { 
            background: #111; color: var(--gold); margin: 0; padding: 5px; 
            font-size: 14px; text-transform: uppercase; letter-spacing: 1px;
        }

        .stat-card {
            background: #000; border: 2px solid #555; padding: 10px; margin-bottom: 10px;
            box-shadow: inset 0 0 10px #000; position: relative; flex-shrink: 0;
        }
        .stat-big { font-size: 20px; font-weight: bold; color: var(--led-green); text-shadow: 0 0 4px var(--led-green); }
        .stat-label { font-size: 9px; color: #888; text-transform: uppercase; margin-bottom: 2px; }
        .stat-row { display: flex; justify-content: space-between; align-items: baseline; }

        .graph-section {
            display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px;
        }
        .graph-container {
            background: #051005; border: 2px solid #444; padding: 5px;
            display: flex; flex-direction: column;
        }
        .graph-label {
            font-size: 10px; color: var(--led-green); opacity: 0.8; margin-bottom: 4px;
            font-weight: bold; letter-spacing: 1px;
        }
        
        #tool-info-card {
            background: #1a1a1a; 
            border: 2px solid #666; 
            border-top: 4px solid #888;
            padding: 10px;
            margin-top: auto;
            margin-bottom: 10px;
            display: flex; flex-direction: column; align-items: center;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            position: relative;
        }
        /* Blue Screen Effect */
        .info-screen {
            background: #001133;
            border: 2px inset #444;
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center;
            margin-bottom: 5px;
        }
        
        .card-icon { font-size: 32px; margin-bottom: 5px; filter: drop-shadow(0 2px 4px #000); }
        .card-title { color: #fff; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; font-size: 12px; letter-spacing: 1px; border-bottom: 1px solid #449; width: 100%; padding-bottom: 4px;}
        .card-desc { font-size: 10px; color: #aaccff; line-height: 1.4; margin-bottom: 8px; text-align: left; width: 100%; }
        
        .status-legend {
            width: 100%; border-top: 1px dashed #449; padding-top: 6px;
            display: flex; justify-content: space-around;
        }
        .legend-item { display: flex; align-items: center; gap: 4px; font-size: 9px; color: #889; }
        .dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; }

        .controls-panel {
            background: #111; border: 1px solid #444; padding: 10px;
            border-radius: 4px; font-size: 11px; color: #aaa;
        }
        .control-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        kbd { background: #333; color: #fff; padding: 1px 4px; border: 1px solid #555; border-radius: 3px; font-weight: bold; font-family: monospace;}

        /* --- Toolbar --- */
        #toolbar-wrapper {
            width: 100%;
            background: #1a1a1a;
            padding: 5px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-top: 4px solid #333;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.5);
            flex-shrink: 0;
        }
        
        #tabs { display: flex; gap: 4px; margin-bottom: -2px; z-index: 5; }
        .tab-btn {
            background: #222; border: 1px solid #444; border-bottom: none;
            color: #888; padding: 4px 12px; font-size: 11px; cursor: pointer;
            border-top-left-radius: 4px; border-top-right-radius: 4px;
            font-weight: bold; transition: all 0.2s; position: relative;
        }
        .tab-btn:hover { background: #333; color: #aaa; }
        .tab-btn.active {
            background: #444; color: var(--gold); border-color: var(--gold); border-bottom: 4px solid #444;
            margin-bottom: -4px; padding-bottom: 8px;
        }
        .lock-icon { font-size: 8px; margin-left: 4px; }

        #toolbar-container {
            background: linear-gradient(to bottom, #444, #2a2a2a);
            border: 2px solid var(--gold); border-radius: 8px;
            padding: 8px 15px; display: flex; gap: 8px; 
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8), 0 5px 15px rgba(0,0,0,0.5);
            justify-content: center;
            width: 90%; max-width: 800px;
        }

        .tool-btn {
            flex: 1; /* Take up container */
            height: 70px;
            background: linear-gradient(to bottom, #555, #333);
            border-top: 2px solid #666; border-left: 2px solid #666;
            border-right: 2px solid #222; border-bottom: 2px solid #222;
            border-radius: 6px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; position: relative;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        .tool-btn:hover { background: linear-gradient(to bottom, #666, #444); }
        .tool-btn:active { transform: translate(1px, 1px); box-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .tool-btn.active { 
            border: 2px solid var(--led-green); background: #222; 
            box-shadow: inset 0 0 10px var(--led-green);
            transform: translate(1px, 1px);
        }
        /* Lock style for mystery items */
        .tool-btn.mystery {
            background: #111; border-color: #333; cursor: not-allowed;
        }
        .tool-btn.mystery .tool-icon { filter: blur(4px) grayscale(1); opacity: 0.3; }
        .tool-btn.mystery .tool-name { color: #555; }
        
        .tool-key { position: absolute; top: 2px; left: 3px; font-size: 9px; color: var(--gold); font-weight: bold; }
        .tool-icon { font-size: 24px; margin-bottom: 2px; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5)); }
        .tool-name { font-size: 9px; color: #fff; text-transform: uppercase; margin-bottom: 2px; }
        .tool-cost { font-size: 9px; color: var(--gold); background: #000; padding: 0 3px; border-radius: 2px; }

        /* --- Modals & Notifications --- */
        #inspector {
            position: absolute; width: 180px;
            background: #1a2634; border: 4px solid var(--usa-red);
            padding: 10px; display: none; z-index: 40; box-shadow: 5px 5px 10px rgba(0,0,0,0.5);
            font-family: 'Courier New', Courier, monospace; color: #fff;
        }
        .insp-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; border-bottom: 1px dotted #666; align-items: center; }
        .insp-btn { background: #c00; color: #fff; border: none; font-size: 10px; cursor: pointer; padding: 4px 8px; border-radius: 3px; }

        .notification {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: #000; color: var(--led-red); border: 2px solid var(--led-red);
            padding: 8px 20px; font-family: monospace; font-weight: bold;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 50;
        }

        #modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 100;
        }
        
        /* Intro Modal */
        .modal-content {
            background: #1a2634; border: 4px solid var(--usa-red); padding: 30px;
            max-width: 450px; text-align: center; color: #fff; border-radius: 8px;
            box-shadow: 0 0 30px var(--usa-red);
        }
        
        /* Victory Report Card Styling */
        #victory-report {
            background: #1a2634;
            color: #eee;
            font-family: 'Courier New', monospace;
            width: 500px;
            padding: 30px;
            border: 4px solid var(--usa-red);
            box-shadow: 0 0 30px var(--usa-red);
            border-radius: 8px;
            text-align: left;
            position: relative;
        }
        #victory-report::before {
            display: none;
        }
        .victory-header {
            display: flex; align-items: center; justify-content: center; gap: 10px;
            font-weight: bold; font-size: 18px; color: var(--gold);
            border-bottom: 2px solid var(--usa-red); padding-bottom: 10px; margin-bottom: 15px;
        }
        .victory-header img {
            width: 30px; height: 20px;
        }
        .report-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; }
        .report-divider { border-bottom: 1px solid #555; margin: 10px 0; }
        .grade-stamp {
            position: absolute; top: 40px; right: 30px;
            font-size: 80px; color: #FF3333;
            font-weight: bold; border: 5px solid #FF3333;
            padding: 0 20px; transform: rotate(-15deg); border-radius: 10px;
            text-shadow: 0 0 20px rgba(255, 51, 51, 0.8);
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.5);
        }
        
        .refresh-btn {
            position: absolute; top: 10px; right: 10px;
            background: #ddd; border: 1px solid #999;
            width: 24px; height: 24px; border-radius: 50%;
            cursor: pointer; font-size: 14px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
        }
        .refresh-btn:hover { background: #ccc; }

        .btn-primary {
            background: var(--usa-blue); color: #fff; border: 2px solid #aaa;
            padding: 10px 20px; font-size: 16px; font-family: monospace; font-weight: bold;
            cursor: pointer; margin-top: 20px; box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            margin-right: 10px;
        }
        .btn-secondary {
            background: #444; color: #fff; border: 2px solid #aaa;
            padding: 10px 20px; font-size: 16px; font-family: monospace; font-weight: bold;
            cursor: pointer; margin-top: 20px; box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

    <div id="mobile-warning">
        <div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: bold; font-size: 18px; color: var(--gold); border-bottom: 2px solid var(--usa-red); padding-bottom: 10px; margin-bottom: 15px;">
                <img src="american_flag.svg" alt="USA" style="width: 30px; height: 20px;">
                USA 250 ‚Ä¢ FACTORY
                <img src="american_flag.svg" alt="USA" style="width: 30px; height: 20px;">
            </div>
            <div class="mobile-warning-title">MORE SPACE NEEDED</div>
            <p>Manufacturing operations require more room to operate efficiently.</p>
            <p>Please access this simulation on a desktop or laptop with a larger screen (1050x700px minimum).</p>
            <p class="mobile-warning-footer">A factory floor can't fit in your pocket! üè≠</p>
        </div>
    </div>

    <div class="sparks">
        <canvas id="fireworksCanvas"></canvas>
    </div>

    <div id="game-wrapper">
        <div id="game-frame">
            <div class="year-badge year-badge-left">1776</div>
            <div class="year-badge year-badge-right">2026</div>
            <a href="https://www.kaizen.io/" target="_blank" class="logo-badge logo-badge-left" style="cursor: pointer; text-decoration: none;">
                <img src="images/favicon.svg" alt="Kaizen">
                <img src="images/favicon-reverse.svg" alt="Kaizen Reverse">
            </a>
            <a href="https://www.kaizen.io/" target="_blank" class="logo-badge logo-badge-right" style="cursor: pointer; text-decoration: none;">
                <img src="images/favicon-reverse.svg" alt="Kaizen Reverse">
                <img src="images/favicon.svg" alt="Kaizen">
            </a>
            <div id="game-container">
                <canvas id="gameCanvas"></canvas>
                <div id="notification" class="notification">ALERT</div>
                
                <div id="inspector">
                    <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                        <strong id="insp-name">UNIT</strong>
                        <button class="insp-btn" onclick="closeInspector()">X</button>
                    </div>
                    <div id="insp-content"></div>
                </div>
            </div>
        </div>

        <div id="toolbar-wrapper">
            <div id="tabs">
                <div class="tab-btn active" id="tab-1">LVL 1</div>
                <div class="tab-btn" id="tab-2">LVL 2 <span class="lock-icon" style="display: inline;">üîí</span></div>
                <div class="tab-btn" id="tab-3">LVL 3 <span class="lock-icon" style="display: inline;">üîí</span></div>
                <div class="tab-btn" id="tab-4">LVL 4 <span class="lock-icon" style="display: inline;">üîí</span></div>
            </div>
            <div id="toolbar-container"><div class="tool-btn active">
                    <div class="tool-key">1</div>
                    <div class="tool-icon" style="color:#37474f">‚û°</div>
                    <div class="tool-name">BELT</div>
                    <div class="tool-cost">$10</div>
                </div><div class="tool-btn ">
                    <div class="tool-key">2</div>
                    <div class="tool-icon" style="color:#fbc02d">ü¶æ</div>
                    <div class="tool-name">ARM</div>
                    <div class="tool-cost">$30</div>
                </div><div class="tool-btn ">
                    <div class="tool-key">3</div>
                    <div class="tool-icon" style="color:#c62828">üî¥</div>
                    <div class="tool-name">PLASTIC</div>
                    <div class="tool-cost">$100</div>
                </div><div class="tool-btn ">
                    <div class="tool-key">4</div>
                    <div class="tool-icon" style="color:#78909c">‚¨ú</div>
                    <div class="tool-name">STEEL</div>
                    <div class="tool-cost">$150</div>
                </div><div class="tool-btn ">
                    <div class="tool-key">5</div>
                    <div class="tool-icon" style="color:#0277bd">‚öôÔ∏è</div>
                    <div class="tool-name">MILL</div>
                    <div class="tool-cost">$500</div>
                </div><div class="tool-btn ">
                    <div class="tool-key">6</div>
                    <div class="tool-icon" style="color:#ef6c00">üè≠</div>
                    <div class="tool-name">PRESS</div>
                    <div class="tool-cost">$800</div>
                </div><div class="tool-btn ">
                    <div class="tool-key">7</div>
                    <div class="tool-icon" style="color:#2e7d32">üí≤</div>
                    <div class="tool-name">SELL</div>
                    <div class="tool-cost">$100</div>
                </div></div>
        </div>
    </div>

    <div id="stats-sidebar">
        <div class="panel-header">
            <h1>USA MANUFACTURING 1776 - 2026</h1>
        </div>
        
        <div class="stat-card">
            <div class="stat-row">
                <div>
                    <div class="stat-label">REVENUE</div>
                    <div class="stat-big" style="color:var(--gold)" id="moneyDisplay">$600</div>
                </div>
                <div style="text-align:right">
                    <div class="stat-label">TIER</div>
                    <div class="stat-big" id="levelDisplay">1</div>
                </div>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#0f0; border-top:1px dashed #333; padding-top:5px;">
                &gt; NEXT: <span id="nextUnlockDisplay" style="color:#fff">50 PARTS</span>
            </div>
        </div>

        <div class="stat-card">
            <div class="stat-row">
                <span class="stat-label">TIME</span>
                <span style="font-family:monospace; font-weight:bold; color:var(--led-red);" id="timeDisplay">00:00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">GOAL</span>
                <span style="color:var(--led-green); font-weight:bold">$1M</span>
            </div>
        </div>

        <div class="graph-section">
            <div class="graph-container">
                <div class="graph-label">INPUT RATE (Baubles/Steel)</div>
                <canvas id="graphResources" width="240" height="80"></canvas>
            </div>
            <div class="graph-container">
                <div class="graph-label">OUTPUT RATE (Parts)</div>
                <canvas id="graphProduction" width="240" height="80"></canvas>
            </div>
            <div class="graph-container">
                <div class="graph-label">REVENUE RATE ($/min)</div>
                <canvas id="graphRevenue" width="240" height="80"></canvas>
            </div>
        </div>

        <!-- Info Card -->
        <div id="tool-info-card">
            <div class="info-screen">
                <div class="card-icon" id="card-icon" style="color: rgb(55, 71, 79);">‚û°</div>
                <div class="card-title" id="card-title">BELT</div>
                <div class="card-desc" id="card-desc">Standard Conveyor. Moves items forward continuously.</div>
                
                <!-- Status Legend -->
                <div class="status-legend" id="status-legend" style="display:none;">
                    <div class="legend-item"><span class="dot" style="background:#39ff14"></span> OK</div>
                    <div class="legend-item"><span class="dot" style="background:#ffd700"></span> FULL</div>
                    <div class="legend-item"><span class="dot" style="background:#ff0000"></span> ERR</div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls-panel">
            <div style="margin-bottom:6px; font-weight:bold; color:#fff; border-bottom:1px solid #444; padding-bottom:2px;">OPERATOR CONTROLS</div>
            <div class="control-row"><span>NAV TABS</span> <kbd>Shift+1-4</kbd></div>
            <div class="control-row"><span>SELECT TOOL</span> <kbd>1-9</kbd></div>
            <div class="control-row"><span>ROTATE</span> <kbd>R</kbd></div>
            <div class="control-row"><span>BUILD/CFG</span> <kbd>L-Click</kbd></div>
            <div class="control-row"><span>SCRAP</span> <kbd>R-Click</kbd></div>
            <div class="control-row"><span>MANUAL</span> <kbd>I</kbd></div>
        </div>
    </div>

    <div id="modal-overlay">
        <!-- Attribution Footer -->
        <div id="attribution-footer" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); text-align: center; color: #ccc; font-size: 14px; z-index: 101; background: #1a2634; padding: 12px 30px; border-radius: 8px; border: 4px solid var(--usa-red); box-shadow: 0 0 30px var(--usa-red);">
            <div style="color: var(--gold); font-weight: bold; margin-bottom: 5px; font-size: 13px;">USA 250th Anniversary Edition</div>
            Original concept by <a href="https://x.com/aphysicist" target="_blank" style="color: #4A9EFF; text-decoration: none;">Aaron Slodov</a>
            and <a href="https://x.com/atomic_inc" target="_blank" style="color: #4A9EFF; text-decoration: none;">Atomic Industries</a>
            ‚Ä¢ <a href="https://gemini.google.com/share/01013b32007e" target="_blank" style="color: #4A9EFF; text-decoration: none;">Play original ‚Üí</a>
            <br>
            American Reindustrialization by Hondo, Hawk and Kijana Woodard of <a href="https://www.kaizen.io/" target="_blank" style="color: #4A9EFF; text-decoration: none;">kaizen.io</a>
            ‚Ä¢ Christmas Break 2025
            ‚Ä¢ <a href="changes/index.html" target="_blank" style="color: var(--industrial-orange); text-decoration: none;">üìã Changelog</a>
        </div>

        <!-- Intro -->
        <div id="intro-modal" class="modal-content">
            <h2 style="color: var(--gold); margin-top:0;">MANUFACTURING SIM ‚Ä¢ USA 250</h2>
            <p style="color: #ccc; font-size: 12px; margin-bottom: 5px;">1776 - 2026</p>
            <p style="color: #aaa; font-size: 11px; margin-bottom: 20px; font-style: italic;">Celebrating 250 Years of American Innovation</p>
            <p><strong>MISSION: MANUFACTURE AMERICAN MADE PARTS</strong></p>
            <ul style="text-align: left; margin: 20px 0; font-size: 13px; line-height: 1.6; list-style: none; padding-left: 10px;">
                <li>üî¥ <strong>Plastic</strong> + üßä <strong>Mold</strong> = ‚≠ê <strong>Part</strong></li>
                <li>‚öôÔ∏è <strong>Machines</strong> do NOT auto-load.</li>
                <li>ü¶æ <strong>Arms</strong> are required to move items.</li>
                <li>üñ±Ô∏è <strong>Click Machines</strong> to manage inventory.</li>
                <li>‚å®Ô∏è <strong>Press I</strong> anytime for help.</li>
                <li>üìä <strong>Press V</strong> to view victory report.</li>
            </ul>
            <div id="intro-buttons" style="display: flex; gap: 10px; justify-content: center;">
                <button id="btn-start" class="btn-primary" onclick="startGame()">START PRODUCTION</button>
                <button id="btn-continue" class="btn-primary" onclick="continueGame()" style="display: none;">CONTINUE</button>
                <button id="btn-reset" class="btn-secondary" onclick="resetGame()" style="display: none;">NEW FACILITY</button>
            </div>
        </div>

        <!-- Victory Report -->
        <div id="win-modal" style="display:none; justify-content:center; align-items:center; height:100%;">
            <div id="victory-report">
                <div class="victory-header">
                    <img src="american_flag.svg" alt="USA">
                    USA 250 ‚Ä¢ FACTORY
                    <img src="american_flag.svg" alt="USA">
                </div>
                <button class="refresh-btn" onclick="populateVictoryReport()">‚Üª</button>
                <div class="grade-stamp" id="gradeStamp">A</div>
                <div class="report-row">
                    <span>DATE:</span> <span id="reportDate">DEC 25 2025</span>
                </div>
                <div class="report-row">
                    <span>FOREMAN:</span> <span>YOU</span>
                </div>
                
                <div class="report-divider"></div>
                
                <div style="font-weight:bold; margin-bottom:10px;">PRODUCTION METRICS</div>
                <div class="report-row">
                    <span>TOTAL REVENUE:</span> <span id="repRevenue">$0</span>
                </div>
                <div class="report-row">
                    <span>TIME ELAPSED:</span> <span id="repTime">00:00</span>
                </div>
                <div class="report-row">
                    <span>PEAK EFFICIENCY:</span> <span id="repPeak">0 PPM</span>
                </div>
                
                <div class="report-divider"></div>
                
                <div style="font-weight:bold; margin-bottom:10px;">MATERIAL CONSUMPTION</div>
                <div class="report-row">
                    <span>PLASTIC PELLETS:</span> <span id="repPlastic">0</span>
                </div>
                <div class="report-row">
                    <span>STEEL BLOCKS:</span> <span id="repSteel">0</span>
                </div>
                <div class="report-row">
                    <span>MOLDS CUT:</span> <span id="repMolds">0</span>
                </div>
                <div class="report-row">
                    <span>PARTS SHIPPED:</span> <span id="repParts">0</span>
                </div>

                <div class="report-divider"></div>
                <div style="text-align:center; font-size:11px; margin-top:15px; color:#aaa;">
                    <a href="https://www.kaizen.io>" style="color: #4A9EFF; text-decoration: none;">kaizen.io</a><br>
                    MADE IN USA <img src="american_flag.svg" alt="USA" style="width:12px; vertical-align:middle;">
                    2026 ¬© All Rights Reserved.
                </div>
                
                <div style="text-align:center;">
                    <button class="btn-primary" onclick="continueGame()">CONTINUE OPERATIONS</button>
                    <button class="btn-secondary" onclick="resetGame()">NEW FACILITY</button>
                </div>
            </div>
        </div>

    </div>

    <!-- ARM Configuration Modal -->
    <div id="arm-config" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#1a2634; padding:30px; border-radius:12px; border:4px solid var(--usa-red); box-shadow:0 0 30px var(--usa-red); z-index:1000; max-width:500px;">
        <h3 style="color:var(--gold); margin-top:0; text-align:center;">ARM CONFIGURATION</h3>

        <!-- Filter Section -->
        <div id="filter-section" style="margin-bottom:30px;">
            <h4 style="color:var(--usa-red); margin-bottom:10px;">ITEM FILTER</h4>
            <p style="color:#aaa; font-size:12px; margin-bottom:15px;">Select which item type this arm should pick up:</p>
            <div style="display:grid; grid-template-columns:repeat(2, 1fr); gap:8px;">
                <button id="filter-all" class="btn-secondary" style="padding:10px; font-size:13px; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:18px;">‚ö°</span><span>ALL</span>
                </button>
                <button id="filter-plastic" class="btn-secondary" style="padding:10px; font-size:13px; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:18px;">üî¥</span><span>PLASTIC</span>
                </button>
                <button id="filter-steel" class="btn-secondary" style="padding:10px; font-size:13px; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:18px;">‚¨ú</span><span>STEEL</span>
                </button>
                <button id="filter-mold" class="btn-secondary" style="padding:10px; font-size:13px; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:18px;">üü´</span><span>MOLD</span>
                </button>
                <button id="filter-mold_quad" class="btn-secondary" style="padding:10px; font-size:13px; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:18px;">üü´</span><span>QUAD MOLD</span>
                </button>
                <button id="filter-part" class="btn-secondary" style="padding:10px; font-size:13px; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:18px;">‚≠ê</span><span>PART</span>
                </button>
            </div>
        </div>

        <!-- Direction Section -->
        <div id="direction-section">
            <h4 style="color:var(--usa-red); margin-bottom:10px;">DELIVERY DIRECTION</h4>
            <p style="color:#aaa; font-size:12px; margin-bottom:15px;">Select where this arm delivers items:</p>
            <div style="display:grid; grid-template-columns:repeat(3, 80px); gap:10px; margin:0 auto; width:fit-content;">
                <div></div>
                <button id="dir-up" class="btn-secondary" style="padding:20px; font-size:24px;">‚Üë</button>
                <div></div>
                <button id="dir-left" class="btn-secondary" style="padding:20px; font-size:24px;">‚Üê</button>
                <div style="display:flex; align-items:center; justify-content:center; color:#555;">ü¶æ</div>
                <button id="dir-right" class="btn-secondary" style="padding:20px; font-size:24px;">‚Üí</button>
                <div></div>
                <button id="dir-down" class="btn-secondary" style="padding:20px; font-size:24px;">‚Üì</button>
                <div></div>
            </div>
        </div>

        <div style="text-align:center; margin-top:25px;">
            <button class="btn-secondary" onclick="closeArmConfig()" style="padding:10px 30px;">CLOSE</button>
        </div>
    </div>

    <script>
        // Grid dimensions are defined in head script
        const TILE_SIZE = window.TILE_SIZE;
        const GRID_W = window.GRID_W;
        const GRID_H = window.GRID_H;
        const TICK_RATE = 1000 / 60;

        const C_PLASTIC = '#d32f2f';
        const C_STEEL = '#cfd8dc';
        const C_MOLD = '#81d4fa';
        const C_PART = '#ffd700'; 
        
        const ITEM = { PLASTIC: 'plastic', STEEL: 'steel', MOLD: 'mold', PART: 'part', MOLD_QUAD: 'mold_quad' };

        const LEVELS = {
            1: { reqParts: 0 },
            2: { reqParts: 50 },
            3: { reqParts: 250 },
            4: { reqParts: 1000 },
        };

        // Define all building variants
        const ALL_BUILDINGS = {
            // BELT variants
            BELT: { id: 'belt', name: 'BELT', cost: 10, color: '#90a4ae', icon: '‚ñ∂', reqLevel: 1, transportSpeed: 0.05, desc: "Standard Conveyor. Moves items forward continuously." },
            BELT_F: { id: 'belt_fast', name: 'FAST BELT', cost: 50, color: '#d32f2f', icon: '‚ñ∂‚ñ∂', reqLevel: 2, transportSpeed: 0.10, desc: "High Speed Conveyor. Moves items 2x faster than standard belts." },

            // ARM variants
            ARM: { id: 'arm_basic', name: 'ARM', cost: 30, color: '#fbc02d', icon: 'ü¶æ', reqLevel: 1, isArm: true, speed: 1.0, desc: "Robot Arm. Moves items from BELTS to MACHINES. Essential for automation." },
            ARM_F: { id: 'arm_filter', name: 'FILTER ARM', cost: 100, color: '#8e24aa', icon: 'üî¨', reqLevel: 2, isArm: true, speed: 1.5, canFilter: true, desc: "Smart Filter Arm. Click placed arm to select item type. Ignores other items." },
            ARM_S: { id: 'arm_smart', name: 'SMART ARM', cost: 200, color: '#006064', icon: '‚ö°', reqLevel: 3, isArm: true, speed: 3.0, canFilter: true, desc: "High-Speed Servo Arm. Transfers items 3x faster." },
            ARM_M: { id: 'arm_mega', name: 'MEGA ARM', cost: 1000, color: '#64b5f6', icon: 'ü¶æM', reqLevel: 4, isArm: true, speed: 3.0, canFilter: true, canDirectDeliver: true, desc: "Omni-Directional Mega Arm. Click to set delivery direction (Up/Down/Left/Right). 3x speed." },

            // PLASTIC SOURCE variants
            SRC_P: { id: 'src_p', name: 'PLASTIC', cost: 100, color: '#c62828', icon: 'üî¥', reqLevel: 1, output: ITEM.PLASTIC, speed: 60, desc: "Infinite source of Red Plastic Pellets. Used in Injection Presses." },
            SRC_P_F: { id: 'src_p_fast', name: 'HI-FLOW PLASTIC', cost: 250, color: '#d32f2f', icon: 'üî¥+', reqLevel: 2, output: ITEM.PLASTIC, speed: 30, desc: "High-Volume Plastic Hopper. Outputs 2x faster." },
            SRC_P_M: { id: 'src_p_mega', name: 'MEGA PLASTIC', cost: 500, color: '#b71c1c', icon: 'üî¥M', reqLevel: 4, output: ITEM.PLASTIC, speed: 15, desc: "Ultra High-Speed Plastic Extruder. Outputs 4x faster than standard." },

            // STEEL SOURCE variants
            SRC_S: { id: 'src_s', name: 'STEEL', cost: 150, color: '#78909c', icon: '‚¨ú', reqLevel: 1, output: ITEM.STEEL, speed: 120, desc: "Infinite source of Steel Blocks. Used to cut Molds." },
            SRC_S_F: { id: 'src_s_fast', name: 'HEAVY STEEL', cost: 350, color: '#546e7a', icon: '‚¨ú+', reqLevel: 3, output: ITEM.STEEL, speed: 60, desc: "Heavy Duty Steel Stock. Outputs 2x faster." },

            // MILL variants
            CNC: { id: 'cnc', name: 'MILL', cost: 500, color: '#0277bd', icon: '‚öôÔ∏è', reqLevel: 1, recipe: { in: ITEM.STEEL, out: ITEM.MOLD, time: 180 }, desc: "Subtractive Manufacturing. Cuts 1 Steel into 1 Mold." },
            CNC_F: { id: 'cnc_fast', name: 'TURBO MILL', cost: 1500, color: '#1565c0', icon: '‚öôÔ∏è+', reqLevel: 3, recipe: { in: ITEM.STEEL, out: ITEM.MOLD, time: 90 }, desc: "High-RPM CNC Mill. Cuts molds 2x faster." },
            CNC_M: { id: 'cnc_mega', name: 'MEGA CNC', cost: 3000, color: '#004d40', icon: '‚öôÔ∏èM', reqLevel: 4, recipe: { in: ITEM.STEEL, out: ITEM.MOLD_QUAD, time: 180 }, desc: "5-Axis Mega Mill. Cuts Steel into Quad-Cavity Molds (4x Output potential)." },

            // PRESS variants
            PRESS: { id: 'press', name: 'PRESS', cost: 800, color: '#ef6c00', icon: 'üè≠', reqLevel: 1, recipe: { in: ITEM.PLASTIC, out: ITEM.PART, time: 60 }, maxLife: 20, desc: "Injection Molding Machine. Requires 1 Plastic + 1 Mold. Molds degrade after 20 cycles." },
            PRESS_M: { id: 'press_mega', name: 'MEGA PRESS', cost: 2500, color: '#e65100', icon: 'üè≠M', reqLevel: 4, recipe: { in: ITEM.PLASTIC, out: ITEM.PART, time: 30 }, maxLife: 40, desc: "Industrial Press. 2x Speed. Supports Quad-Molds (4x output). Molds last 40 cycles." },

            // SELL
            BIN: { id: 'bin', name: 'SELL', cost: 100, color: '#2e7d32', icon: 'üí≤', reqLevel: 1, desc: "Market Export. Sells items. PRICES: Part=$45, Mold=$20, Raw=$1." },
        };

        // Define tool slots - each slot shows the best version available at each level
        const TOOL_SLOTS = [
            { slot: 1, variants: ['BELT', 'BELT_F'] },                    // Hotkey 1
            { slot: 2, variants: ['ARM', 'ARM_F', 'ARM_S', 'ARM_M'] },    // Hotkey 2
            { slot: 3, variants: ['SRC_P', 'SRC_P_F', 'SRC_P_M'] },       // Hotkey 3
            { slot: 4, variants: ['SRC_S', 'SRC_S_F'] },                  // Hotkey 4
            { slot: 5, variants: ['CNC', 'CNC_F', 'CNC_M'] },             // Hotkey 5
            { slot: 6, variants: ['PRESS', 'PRESS_M'] },                  // Hotkey 6
            { slot: 7, variants: ['BIN'] },                               // Hotkey 7
        ];

        // Legacy BUILDINGS object for backward compatibility
        const BUILDINGS = ALL_BUILDINGS;

        const SELL_PRICES = { [ITEM.PART]: 45, [ITEM.MOLD]: 20, [ITEM.STEEL]: 1, [ITEM.PLASTIC]: 1, [ITEM.MOLD_QUAD]: 100 };

        let canvas, ctx, gResCanvas, gResCtx, gProdCanvas, gProdCtx, gRevCanvas, gRevCtx;
        let money = 600;
        let lifetimeRevenue = 600;
        let partsSoldTotal = 0;
        let totalPlasticUsed = 0;
        let totalSteelUsed = 0;
        let totalMoldsMade = 0;
        let level = 1;
        let currentTab = 1;
        let gameRunning = false;
        let hasWon = false;
        let startTime = 0;
        let selectedTool = 'belt';
        let selectedSlot = 1; // Track which slot number is selected (1-7)
        let rotation = 0;
        let isDragging = false;
        let mouseGridPos = { x: -1, y: -1 };
        
        let grid = [];
        let buildings = [];
        let items = [];
        let inspectedBuilding = null;
        let lastInspectorStructure = '';
        let metrics = { history: [], current: { plastic: 0, steel: 0, mold: 0, part: 0, dollars: 0 } };

        class Tile { constructor(x, y) { this.x = x; this.y = y; this.building = null; } }

        class Building {
            constructor(type, x, y, rot) {
                this.type = type;
                this.x = x; this.y = y; this.rot = rot;
                this.timer = 0;
                this.inventory = { [ITEM.PLASTIC]: 0, [ITEM.STEEL]: 0, [ITEM.MOLD]: 0, [ITEM.MOLD_QUAD]: 0 };
                this.outputBuffer = null;
                this.outputCount = 0;
                this.moldLife = 0;
                this.maxMoldLife = type.maxLife || 0;
                this.heldItem = null;
                this.armAnim = 0;
                this.filter = null;
                this.lastSoldTime = 0;
                this.deliverDir = rot; // For MEGA ARM - delivery direction (default: forward)
            }
            cycleFilter() {
                if (!this.type.canFilter) return;
                const types = [null, ITEM.PLASTIC, ITEM.STEEL, ITEM.MOLD, ITEM.MOLD_QUAD, ITEM.PART];
                let idx = types.indexOf(this.filter);
                this.filter = types[(idx + 1) % types.length];
            }
            update() {
                if (this.type.isArm) this.updateArm();
                else this.updateMachine();
            }
            updateArm() {
                let speed = this.type.speed * 0.05;
                // Use deliverDir for delivery target (MEGA ARM can deliver in any cardinal direction)
                let deliveryDirection = this.type.canDirectDeliver ? this.deliverDir : this.rot;

                if (this.heldItem) {
                    if (this.armAnim < 1.0) this.armAnim = Math.min(1.0, this.armAnim + speed);
                    else {
                        let targetXY = getNeighbor(this.x, this.y, deliveryDirection);
                        if (this.attemptDrop(targetXY, this.heldItem)) this.heldItem = null;
                    }
                } else {
                    if (this.armAnim > 0) this.armAnim = Math.max(0, this.armAnim - speed);
                    else {
                        let sourceXY = getNeighbor(this.x, this.y, (this.rot + 2) % 4);
                        let targetXY = getNeighbor(this.x, this.y, deliveryDirection);
                        let item = this.attemptPickup(sourceXY, targetXY);
                        if (item) this.heldItem = item;
                    }
                }
            }
            updateMachine() {
                if (this.type.output) {
                    this.timer++;
                    if (this.timer >= this.type.speed) {
                        if (!this.outputBuffer) {
                            this.outputBuffer = this.type.output;
                            this.outputCount = 1;
                            if (this.type.output === ITEM.PLASTIC) { metrics.current.plastic++; }
                            if (this.type.output === ITEM.STEEL) { metrics.current.steel++; }
                            this.timer = 0;
                        }
                    }
                }
                
                if (this.type.id.includes('cnc')) {
                    if (!this.outputBuffer && this.inventory[ITEM.STEEL] > 0) {
                        this.timer++;
                        if (this.timer >= this.type.recipe.time) {
                            this.inventory[ITEM.STEEL]--;
                            totalSteelUsed++; // Track Consumption
                            if (this.type.id === 'cnc_mega') {
                                this.outputBuffer = ITEM.MOLD_QUAD;
                            } else {
                                this.outputBuffer = ITEM.MOLD;
                                metrics.current.mold++;
                            }
                            totalMoldsMade++;
                            this.outputCount = 1;
                            this.timer = 0;
                        }
                    } else if (this.inventory[ITEM.STEEL] === 0) this.timer = 0;
                }

                if (this.type.id.includes('press')) {
                    if (this.moldLife <= 0) {
                        if (this.inventory[ITEM.MOLD_QUAD] > 0 && this.type.id === 'press_mega') {
                            this.inventory[ITEM.MOLD_QUAD]--;
                            this.moldLife = this.maxMoldLife;
                            this.currentMoldType = ITEM.MOLD_QUAD;
                        } else if (this.inventory[ITEM.MOLD] > 0) {
                            this.inventory[ITEM.MOLD]--;
                            this.moldLife = this.maxMoldLife;
                            this.currentMoldType = ITEM.MOLD;
                        }
                    }

                    if (this.moldLife > 0 && (!this.outputBuffer || (this.outputBuffer === ITEM.PART && this.outputCount < 5))) {
                        let plasticNeeded = (this.currentMoldType === ITEM.MOLD_QUAD) ? 4 : 1;
                        if (this.inventory[ITEM.PLASTIC] >= plasticNeeded) {
                            this.timer++;
                            if (this.timer >= this.type.recipe.time) {
                                this.inventory[ITEM.PLASTIC] -= plasticNeeded;
                                totalPlasticUsed += plasticNeeded; // Track Consumption
                                this.outputBuffer = ITEM.PART;
                                let produced = (this.currentMoldType === ITEM.MOLD_QUAD) ? 4 : 1;
                                this.outputCount += produced;
                                metrics.current.part += produced;
                                this.moldLife--;
                                this.timer = 0;
                            }
                        } else this.timer = 0;
                    } else if (this.moldLife <= 0) this.timer = 0;
                }

                if (this.outputBuffer && this.type.id.includes('src')) {
                    let targetXY = getNeighbor(this.x, this.y, this.rot);
                    if (isValid(targetXY)) {
                        let targetTile = grid[targetXY.y][targetXY.x];
                        if (targetTile.building && targetTile.building.type.transportSpeed) {
                            if (isSpaceFree(targetXY.x, targetXY.y)) {
                                let it = new Item(this.outputBuffer, targetXY.x, targetXY.y);
                                it.sourceDir = (this.rot + 2) % 4; // Crucial for smoothing
                                items.push(it);
                                this.outputCount--;
                                if (this.outputCount <= 0) {
                                    this.outputBuffer = null;
                                    this.outputCount = 0;
                                }
                            }
                        }
                    }
                }
            }
            attemptPickup(pos, targetPos) {
                if (!isValid(pos)) return null;
                let tile = grid[pos.y][pos.x];
                if (!tile.building) return null;
                
                let canAcceptFunc = (itemType) => {
                    if (!isValid(targetPos)) return true;
                    let tTile = grid[targetPos.y][targetPos.x];
                    if (!tTile.building) return true;
                    let b = tTile.building;
                    if (b.type.id.includes('cnc')) {
                        if (itemType === ITEM.STEEL && b.inventory[ITEM.STEEL] >= 5) return false;
                        if (itemType !== ITEM.STEEL) return false;
                    } else if (b.type.id.includes('press')) {
                        if (itemType === ITEM.PLASTIC && b.inventory[ITEM.PLASTIC] >= 20) return false;
                        if (itemType === ITEM.MOLD && b.inventory[ITEM.MOLD] >= 5) return false;
                        if (itemType === ITEM.MOLD_QUAD && b.inventory[ITEM.MOLD_QUAD] >= 5) return false;
                        // Only MEGA PRESS can accept MOLD_QUAD
                        const acceptableItems = b.type.id === 'press_mega'
                            ? [ITEM.PLASTIC, ITEM.MOLD, ITEM.MOLD_QUAD]
                            : [ITEM.PLASTIC, ITEM.MOLD];
                        if (!acceptableItems.includes(itemType)) return false;
                    }
                    return true;
                };

                if (tile.building.outputBuffer && tile.building.outputCount > 0) {
                    let it = tile.building.outputBuffer;
                    if (this.filter && it !== this.filter) return null;
                    if (!canAcceptFunc(it)) return null;
                    
                    tile.building.outputCount--;
                    if (tile.building.outputCount <= 0) tile.building.outputBuffer = null;
                    return it;
                }
                
                if (tile.building.type.transportSpeed) {
                    let bestItem = null, bestProgress = -1;
                    for (let i = 0; i < items.length; i++) {
                        let it = items[i];
                        if (Math.floor(it.x) === pos.x && Math.floor(it.y) === pos.y) {
                            if (this.filter && it.type !== this.filter) continue;
                            if (!canAcceptFunc(it.type)) continue;
                            // Pick item with highest progress (furthest along = FIFO order)
                            if (it.progress > bestProgress) { bestProgress = it.progress; bestItem = it; }
                        }
                    }
                    if (bestItem) { bestItem.markedForDeletion = true; return bestItem.type; }
                }
                return null;
            }
            attemptDrop(pos, itemType) {
                if (!isValid(pos)) return false;
                let tile = grid[pos.y][pos.x];
                if (!tile.building) return false;
                let b = tile.building;
                
                if (b.type.id === 'bin') { 
                    sellItem(itemType); 
                    b.lastSoldTime = Date.now(); // Trigger Animation
                    return true; 
                }
                if (b.type.id.includes('cnc')) {
                    if (itemType === ITEM.STEEL && b.inventory[ITEM.STEEL] < 5) { b.inventory[ITEM.STEEL]++; return true; }
                }
                if (b.type.id.includes('press')) {
                    if (itemType === ITEM.PLASTIC && b.inventory[ITEM.PLASTIC] < 20) { b.inventory[ITEM.PLASTIC]++; return true; }
                    if (itemType === ITEM.MOLD && b.inventory[ITEM.MOLD] < 5) { b.inventory[ITEM.MOLD]++; return true; }
                    // Only MEGA PRESS can accept MOLD_QUAD
                    if (itemType === ITEM.MOLD_QUAD && b.type.id === 'press_mega' && b.inventory[ITEM.MOLD_QUAD] < 5) { b.inventory[ITEM.MOLD_QUAD]++; return true; }
                }
                if (b.type.transportSpeed) {
                    if (isSpaceFree(pos.x, pos.y)) { 
                        let it = new Item(itemType, pos.x, pos.y);
                        // Item entering belt from arm: set sourceDir based on Arm Rotation
                        // Arm is at this.x, this.y with this.rot
                        // Drop is at pos.x, pos.y
                        // Source dir relative to new tile is (ArmRot + 2)%4
                        it.sourceDir = (this.rot + 2) % 4;
                        items.push(it); 
                        return true; 
                    }
                }
                return false;
            }
        }

        class Item {
            constructor(type, x, y) {
                this.type = type; this.x = x; this.y = y; this.progress = 0; this.markedForDeletion = false; 
                this.exitDir = null; this.sourceDir = null; // sourceDir: 0=R,1=D,2=L,3=U (Where it came FROM)
            }
            update() {
                let gx = Math.floor(this.x), gy = Math.floor(this.y);
                if (!isValid({x:gx, y:gy})) { this.markedForDeletion = true; return; }
                let tile = grid[gy][gx];
                if (!tile.building || !tile.building.type.transportSpeed) { this.markedForDeletion = true; return; }
                
                let speed = tile.building.type.transportSpeed;
                if (this.exitDir === null) this.exitDir = tile.building.rot; 
                
                // Determine Source Dir if null (just spawned or glitch)
                if (this.sourceDir === null) {
                    // Assume it came from opposite of exit if unsure, or behind
                    this.sourceDir = (this.exitDir + 2) % 4;
                }

                let dir = this.exitDir;
                let nextX = gx, nextY = gy;
                if (dir === 0) nextX++; if (dir === 1) nextY++; if (dir === 2) nextX--; if (dir === 3) nextY--;
                
                let blocked = false;
                let nextTile = isValid({x:nextX, y:nextY}) ? grid[nextY][nextX] : null;
                if (!nextTile || !nextTile.building || !nextTile.building.type.transportSpeed) {
                    if (this.progress > 0.9) blocked = true;
                }
                for (let other of items) {
                    if (other === this) continue;
                    if (Math.floor(other.x) === gx && Math.floor(other.y) === gy && other.progress > this.progress) {
                        if (other.progress - this.progress < 0.6) blocked = true;
                    }
                    if (Math.floor(other.x) === nextX && Math.floor(other.y) === nextY) {
                        if (this.progress > 0.8 && other.progress < 0.2) blocked = true;
                    }
                }
                if (!blocked) {
                    this.progress += speed;
                    if (this.progress >= 1.0) {
                        if (nextTile && nextTile.building && nextTile.building.type.transportSpeed) {
                            this.x = nextX; this.y = nextY; this.progress = 0; 
                            // New source dir is opposite of where we came from (which was 'dir')
                            this.sourceDir = (dir + 2) % 4; 
                            this.exitDir = null;
                        } else this.progress = 1.0;
                    }
                }
            }
        }

        // --- Core ---
        function isValid(pos) { return pos.x >= 0 && pos.x < GRID_W && pos.y >= 0 && pos.y < GRID_H; }
        function getNeighbor(x, y, rot) {
            if (rot === 0) return { x: x + 1, y: y };
            if (rot === 1) return { x: x, y: y + 1 };
            if (rot === 2) return { x: x - 1, y: y };
            if (rot === 3) return { x: x, y: y - 1 };
            return { x, y };
        }
        function isSpaceFree(x, y) {
            for (let it of items) {
                if (Math.floor(it.x) === x && Math.floor(it.y) === y && it.progress < 0.5) return false;
            }
            return true;
        }

        function init() {
            canvas = document.getElementById('gameCanvas');
            canvas.width = TILE_SIZE * GRID_W;
            canvas.height = TILE_SIZE * GRID_H;
            ctx = canvas.getContext('2d');
            gResCanvas = document.getElementById('graphResources'); gResCtx = gResCanvas.getContext('2d');
            gProdCanvas = document.getElementById('graphProduction'); gProdCtx = gProdCanvas.getContext('2d');
            gRevCanvas = document.getElementById('graphRevenue'); gRevCtx = gRevCanvas.getContext('2d');

            for (let y = 0; y < GRID_H; y++) {
                let row = []; for (let x = 0; x < GRID_W; x++) row.push(new Tile(x, y));
                grid.push(row);
            }
            setupToolbar();
            // Select first available tool
            let firstSlot = TOOL_SLOTS[0];
            let firstTool = null;
            for (let variantKey of firstSlot.variants) {
                let variant = ALL_BUILDINGS[variantKey];
                if (variant.reqLevel <= level) {
                    if (!firstTool || variant.reqLevel > firstTool.reqLevel) {
                        firstTool = variant;
                    }
                }
            }
            if (firstTool) {
                selectedTool = firstTool.id;
                updateInfoCard(firstTool);
            }
            switchTab(1); 

            // Initialize click listeners for tabs
            document.getElementById('tab-1').onclick = () => switchTab(1);
            document.getElementById('tab-2').onclick = () => switchTab(2);
            document.getElementById('tab-3').onclick = () => switchTab(3);
            document.getElementById('tab-4').onclick = () => switchTab(4);

            window.addEventListener('keydown', handleKey);
            canvas.addEventListener('mousedown', handleMouse);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Event delegation for inspector delete buttons
            document.getElementById('insp-content').addEventListener('click', (e) => {
                if (e.target.classList.contains('insp-btn')) {
                    if (e.target.dataset.item) {
                        clearInv(e.target.dataset.item);
                    } else if (e.target.dataset.clear === 'output') {
                        clearOutput();
                    }
                }
            });

            // Auto-save before page unload
            window.addEventListener('beforeunload', saveGameState);

            setInterval(update, TICK_RATE);
            setInterval(updateMetrics, 1000);
            setInterval(updateInspectorUI, 200);
            requestAnimationFrame(draw);

            // Auto-load saved game if exists
            if (loadGameState()) {
                gameRunning = true;
                document.getElementById('modal-overlay').style.display = 'none';
            }
        }

        function startGame() {
            document.getElementById('intro-modal').parentElement.style.display = 'none';
            gameRunning = true; startTime = Date.now();
        }

        function continueGame() {
             document.getElementById('modal-overlay').style.display = 'none';
             gameRunning = true;
        }

        // --- Save/Load System ---
        function saveGameState() {
            const state = {
                buildings: buildings.map(b => ({
                    type: b.type.id,
                    x: b.x,
                    y: b.y,
                    rot: b.rot,
                    deliverDir: b.deliverDir,
                    inventory: b.inventory,
                    outputBuffer: b.outputBuffer,
                    outputCount: b.outputCount,
                    timer: b.timer,
                    moldLife: b.moldLife,
                    currentMoldType: b.currentMoldType
                })),
                items: items.map(i => ({
                    type: i.type,
                    x: i.x,
                    y: i.y,
                    targetX: i.targetX,
                    targetY: i.targetY,
                    progress: i.progress
                })),
                money,
                lifetimeRevenue,
                partsSoldTotal,
                totalPlasticUsed,
                totalSteelUsed,
                totalMoldsMade,
                level,
                currentTab,
                selectedSlot,
                hasWon,
                elapsedTime: Date.now() - startTime,
                metricsHistory: metrics.history
            };
            localStorage.setItem('injectionMoldingSave', JSON.stringify(state));
        }

        function loadGameState() {
            const saved = localStorage.getItem('injectionMoldingSave');
            if (!saved) return false;

            try {
                const state = JSON.parse(saved);

                // Don't load if save is empty (no buildings placed)
                if (!state.buildings || state.buildings.length === 0) {
                    localStorage.removeItem('injectionMoldingSave');
                    return false;
                }

                // Restore buildings
                buildings = state.buildings.map(b => {
                    const type = Object.values(BUILDINGS).find(t => t.id === b.type);
                    if (!type) return null;

                    // Skip buildings outside current grid bounds
                    if (b.y < 0 || b.y >= GRID_H || b.x < 0 || b.x >= GRID_W) {
                        console.warn(`Skipping building at (${b.x}, ${b.y}) - outside grid bounds`);
                        return null;
                    }

                    const building = new Building(type, b.x, b.y, b.rot);
                    building.deliverDir = b.deliverDir !== undefined ? b.deliverDir : b.rot;
                    building.inventory = b.inventory || {};
                    building.outputBuffer = b.outputBuffer;
                    building.outputCount = b.outputCount || 0;
                    building.timer = b.timer || 0;
                    building.moldLife = b.moldLife || 0;
                    building.currentMoldType = b.currentMoldType;
                    grid[b.y][b.x].building = building;
                    return building;
                }).filter(b => b !== null);

                // Restore items
                items = state.items.map(i => {
                    // Skip items outside grid bounds (in pixels)
                    const maxX = GRID_W * TILE_SIZE;
                    const maxY = GRID_H * TILE_SIZE;
                    if (i.x < 0 || i.x > maxX || i.y < 0 || i.y > maxY) {
                        return null;
                    }

                    const item = new Item(i.type, i.x, i.y);
                    item.targetX = i.targetX;
                    item.targetY = i.targetY;
                    item.progress = i.progress || 0;
                    return item;
                }).filter(i => i !== null);

                // Restore game state
                money = state.money;
                lifetimeRevenue = state.lifetimeRevenue;
                partsSoldTotal = state.partsSoldTotal;
                totalPlasticUsed = state.totalPlasticUsed;
                totalSteelUsed = state.totalSteelUsed;
                totalMoldsMade = state.totalMoldsMade;
                level = state.level;
                currentTab = state.currentTab || 1;
                selectedSlot = state.selectedSlot || 1;
                hasWon = state.hasWon || false;
                switchTab(currentTab);
                metrics.history = state.metricsHistory || [];

                // Restore time (adjust startTime to account for elapsed time)
                startTime = Date.now() - (state.elapsedTime || 0);

                updateUI();
                return true;
            } catch (e) {
                console.error('Failed to load save:', e);
                return false;
            }
        }

        function resetGame() {
            // Remove auto-save listener to prevent re-saving during reload
            window.removeEventListener('beforeunload', saveGameState);
            localStorage.removeItem('injectionMoldingSave');
            location.reload();
        }

        function sellItem(type) {
            let val = SELL_PRICES[type];
            money += val;
            lifetimeRevenue += val;
            metrics.current.dollars += val;
            if (type === ITEM.PART) { partsSoldTotal++; checkLevelUp(); }
            if (money >= 1000000 && !hasWon) {
                 hasWon = true;
                 endGame();
            }
            updateUI();
        }

        function checkLevelUp() {
            let nextLvl = level + 1;
            if (LEVELS[nextLvl] && partsSoldTotal >= LEVELS[nextLvl].reqParts) {
                level = nextLvl; showNotification(`LEVEL ${level} UNLOCKED`);
                switchTab(currentTab); 
            }
        }

        function update() {
            if (!gameRunning) return;
            let diff = Math.floor((Date.now() - startTime) / 1000);
            let m = Math.floor(diff/60).toString().padStart(2,'0');
            let s = (diff%60).toString().padStart(2,'0');
            document.getElementById('timeDisplay').innerText = `${m}:${s}`;
            for (let b of buildings) b.update();
            items = items.filter(i => !i.markedForDeletion);
            for (let i of items) i.update();
        }

        function updateMetrics() {
            if (!gameRunning) return;
            metrics.history.push({ ...metrics.current });
            if (metrics.history.length > 60) metrics.history.shift();
            metrics.current = { plastic: 0, steel: 0, mold: 0, part: 0, dollars: 0 };
            drawGraphs();
        }

        // --- Interaction ---
        function switchTab(t) {
            // Can't switch to locked tabs
            if (t > level) {
                return;
            }

            currentTab = t;

            document.querySelectorAll('.tab-btn').forEach((el, idx) => {
                if (idx + 1 === t) el.classList.add('active'); else el.classList.remove('active');
            });

            setupToolbar();
        }

        function renderLockedToolbar(count) {
            const tb = document.getElementById('toolbar-container');
            tb.innerHTML = '';
            for(let i=0; i<count; i++) {
                let div = document.createElement('div');
                div.className = `tool-btn mystery`;
                div.innerHTML = `
                    <div class="tool-key">${i+1}</div>
                    <div class="tool-icon">‚ùì</div>
                    <div class="tool-name">???</div>
                `;
                tb.appendChild(div);
            }
        }

        function setupToolbar() {
            const tb = document.getElementById('toolbar-container');
            tb.innerHTML = '';

            // First, figure out which tool should be selected for the saved slot
            let targetSlot = TOOL_SLOTS.find(s => s.slot === selectedSlot);
            if (targetSlot) {
                let bestVariant = null;
                for (let variantKey of targetSlot.variants) {
                    let variant = ALL_BUILDINGS[variantKey];
                    if (variant.reqLevel <= currentTab) {
                        if (!bestVariant || variant.reqLevel > bestVariant.reqLevel) {
                            bestVariant = variant;
                        }
                    }
                }
                if (bestVariant) {
                    selectedTool = bestVariant.id;
                    updateInfoCard(bestVariant);
                }
            }

            // Now build the toolbar buttons with correct active state
            TOOL_SLOTS.forEach((slot, i) => {
                // Find the highest reqLevel variant that's available up to current tab
                let bestVariant = null;
                for (let variantKey of slot.variants) {
                    let variant = ALL_BUILDINGS[variantKey];
                    if (variant.reqLevel <= currentTab) {
                        if (!bestVariant || variant.reqLevel > bestVariant.reqLevel) {
                            bestVariant = variant;
                        }
                    }
                }

                if (bestVariant) {
                    let div = document.createElement('div');
                    div.className = `tool-btn ${selectedTool === bestVariant.id ? 'active' : ''}`;
                    div.onclick = () => {
                        selectedSlot = slot.slot;
                        setupToolbar();
                    };
                    div.innerHTML = `
                        <div class="tool-key">${slot.slot}</div>
                        <div class="tool-icon" style="color:${bestVariant.color}">${bestVariant.icon}</div>
                        <div class="tool-name">${bestVariant.name}</div>
                        <div class="tool-cost">$${bestVariant.cost}</div>
                    `;
                    tb.appendChild(div);
                }
            });

            // Update tab lock states
            for(let i=1; i<=4; i++) {
                let el = document.getElementById(`tab-${i}`);
                let lockIcon = el.querySelector('.lock-icon');
                if (lockIcon) {
                    if (level >= i) {
                        lockIcon.style.display = 'none';
                    } else {
                        lockIcon.style.display = 'inline';
                    }
                }
            }
        }
        
        function updateInfoCard(b) {
            document.getElementById('card-icon').innerText = b.icon;
            document.getElementById('card-icon').style.color = b.color;
            document.getElementById('card-title').innerText = b.name;
            document.getElementById('card-desc').innerText = b.desc;
            
            // Show Status Legend for Machines, Sources, Bins. Hide for Belts and Arms.
            if (!b.id.includes('belt') && !b.isArm) {
                document.getElementById('status-legend').style.display = 'flex';
            } else {
                document.getElementById('status-legend').style.display = 'none';
            }
        }

        function handleKey(e) {
            if (e.key.toLowerCase() === 'i') {
                // Update button visibility based on game state
                const isGameActive = gameRunning || startTime > 0;
                document.getElementById('btn-start').style.display = isGameActive ? 'none' : 'block';
                document.getElementById('btn-continue').style.display = isGameActive ? 'block' : 'none';
                document.getElementById('btn-reset').style.display = isGameActive ? 'block' : 'none';

                document.getElementById('modal-overlay').style.display = 'flex';
                document.getElementById('intro-modal').style.display = 'block';
                document.getElementById('win-modal').style.display = 'none';
                return;
            }
            if (e.key.toLowerCase() === 'v') {
                // Show victory report card
                if (gameRunning || startTime > 0) {
                    populateVictoryReport();
                    document.getElementById('modal-overlay').style.display = 'flex';
                    document.getElementById('intro-modal').style.display = 'none';
                    document.getElementById('win-modal').style.display = 'flex';
                    gameRunning = false;
                }
                return;
            }
            if (e.key === 'Shift') return;
            if (e.shiftKey) {
                if (e.code === 'Digit1') switchTab(1);
                else if (e.code === 'Digit2') switchTab(2);
                else if (e.code === 'Digit3') switchTab(3);
                else if (e.code === 'Digit4') switchTab(4);
                return;
            }
            if (e.key.toLowerCase() === 'r') rotation = (rotation + 1) % 4;
            if (e.key === 'Escape') closeInspector();
            
            // Use e.code to reliably get digits 1-9
            if (e.code.startsWith('Digit')) {
                let num = parseInt(e.code.replace('Digit',''));
                if (!isNaN(num) && num >= 1 && num <= 9) {
                    // Find the slot for this number
                    let slot = TOOL_SLOTS.find(s => s.slot === num);
                    if (slot) {
                        // Find the best variant available at current tab
                        let bestVariant = null;
                        for (let variantKey of slot.variants) {
                            let variant = ALL_BUILDINGS[variantKey];
                            if (variant.reqLevel <= currentTab) {
                                if (!bestVariant || variant.reqLevel > bestVariant.reqLevel) {
                                    bestVariant = variant;
                                }
                            }
                        }
                        if (bestVariant) {
                            selectedTool = bestVariant.id;
                            selectedSlot = num;
                            setupToolbar();
                            updateInfoCard(bestVariant);
                        }
                    }
                }
            }
        }

        function getMouseGridPos(e) {
            const rect = canvas.getBoundingClientRect();
            return { 
                x: Math.floor((e.clientX - rect.left) / TILE_SIZE), 
                y: Math.floor((e.clientY - rect.top) / TILE_SIZE) 
            };
        }

        function handleMouse(e) {
            if (!gameRunning) return;
            const pos = getMouseGridPos(e);
            if (e.button === 0) {
                if (grid[pos.y] && grid[pos.y][pos.x]) {
                    const tile = grid[pos.y][pos.x];
                    if (tile.building && (tile.building.type.canFilter || tile.building.type.canDirectDeliver)) {
                        openArmConfig(tile.building);
                        return;
                    }
                    if (tile.building && !tile.building.type.isArm && !tile.building.type.transportSpeed) {
                        openInspector(tile.building); return;
                    }
                    placeBuilding(pos.x, pos.y); isDragging = true;
                }
            } else if (e.button === 2) {
                if (inspectedBuilding) {
                    closeInspector();
                } else {
                    removeBuilding(pos.x, pos.y);
                }
            }
        }

        function handleMouseMove(e) {
            mouseGridPos = getMouseGridPos(e);
            if (isDragging && gameRunning) placeBuilding(mouseGridPos.x, mouseGridPos.y);
        }

        function placeBuilding(x, y) {
            if (!isValid({x,y})) return;
            const tile = grid[y][x];
            let bData = Object.values(BUILDINGS).find(b => b.id === selectedTool);
            if (tile.building) {
                if (tile.building.type.id === bData.id && tile.building.rot === rotation) return;
                return;
            }
            if (money >= bData.cost) {
                money -= bData.cost;
                tile.building = new Building(bData, x, y, rotation);
                buildings.push(tile.building);
                updateUI();
            } else showNotification("INSUFFICIENT FUNDS");
        }

        function removeBuilding(x, y) {
            if (!isValid({x,y})) return;
            const tile = grid[y][x];
            if (tile.building) {
                money += Math.floor(tile.building.type.cost * 0.5);
                buildings = buildings.filter(b => b !== tile.building);
                tile.building = null;
                updateUI();
            }
        }

        function openInspector(b) {
            inspectedBuilding = b;
            let insp = document.getElementById('inspector');
            insp.style.display = 'block';
            document.getElementById('insp-name').innerText = b.type.name;

            // Position inspector near the building
            let buildingX = b.x * TILE_SIZE;
            let buildingY = b.y * TILE_SIZE;

            // Try to position to the right of the building
            let inspX = buildingX + TILE_SIZE + 10;
            let inspY = buildingY;

            // Get inspector dimensions (approximate if not yet rendered)
            let inspWidth = 180;
            let inspHeight = insp.offsetHeight || 150;

            // Check if inspector would go off-screen to the right
            if (inspX + inspWidth > GRID_W * TILE_SIZE) {
                // Position to the left instead
                inspX = buildingX - inspWidth - 10;
            }

            // Check if inspector would go off-screen to the left
            if (inspX < 0) {
                // Position below the building instead
                inspX = buildingX;
                inspY = buildingY + TILE_SIZE + 10;
            }

            // Check if inspector would go off-screen at the bottom
            if (inspY + inspHeight > GRID_H * TILE_SIZE) {
                // Move up to fit
                inspY = GRID_H * TILE_SIZE - inspHeight - 10;
            }

            // Ensure it doesn't go above the top
            if (inspY < 0) inspY = 10;

            insp.style.left = inspX + 'px';
            insp.style.top = inspY + 'px';
            insp.style.right = 'auto'; // Clear the fixed right position

            updateInspectorUI();
        }
        function closeInspector() { inspectedBuilding = null; document.getElementById('inspector').style.display = 'none'; }
        function clearInv(type) {
            if (inspectedBuilding && inspectedBuilding.inventory.hasOwnProperty(type)) {
                inspectedBuilding.inventory[type] = 0;
                updateInspectorUI();
            }
        }
        function clearOutput() { 
            if (inspectedBuilding) {
                inspectedBuilding.outputBuffer = null; 
                inspectedBuilding.outputCount = 0;
            }
            updateInspectorUI(); 
        }

        function updateInspectorUI() {
            if (!inspectedBuilding) return;
            let b = inspectedBuilding;

            // Determine structure (what items exist, not their values)
            let structure = '';
            let inventoryKeys = [];
            if (Object.keys(b.inventory).length > 0) {
                for (let k in b.inventory) {
                    if (b.type.id.includes('src')) continue;
                    if (b.type.id.includes('cnc') && k !== ITEM.STEEL) continue;
                    if (b.type.id.includes('press') && k === ITEM.STEEL) continue;
                    inventoryKeys.push(k);
                    structure += k + ',';
                }
            }
            // Always include output row for machines that produce items
            let hasOutput = b.type.output || b.type.recipe?.out;
            structure += hasOutput ? 'output' : '';

            // If structure changed, rebuild HTML
            if (structure !== lastInspectorStructure) {
                let html = '';
                let status = "OPERATIONAL", statusColor = "#4caf50";
                if (b.outputBuffer && b.outputCount >= 5) { status = "OUTPUT FULL"; statusColor = "#ffd700"; }
                else if (b.type.id.includes('press') && b.inventory[ITEM.PLASTIC] === 0) { status = "NO PLASTIC"; statusColor = "#f44336"; }
                else if (b.type.id.includes('press') && b.moldLife <= 0 && b.inventory[ITEM.MOLD] === 0) { status = "NO MOLD"; statusColor = "#f44336"; }

                html += `<div id="insp-status" style="color:${statusColor}; font-weight:bold; margin-bottom:10px;">${status}</div>`;
                for (let k of inventoryKeys) {
                    html += `<div class="insp-row"><span id="insp-${k}">${k.toUpperCase()}: ${b.inventory[k]}</span><button class="insp-btn" data-item="${k}">DEL</button></div>`;
                }
                if (hasOutput) {
                    let outType = b.outputBuffer ? b.outputBuffer.toUpperCase() : 'NONE';
                    let outCount = b.outputCount || 0;
                    html += `<div class="insp-row"><span id="insp-output">OUT: ${outType} (x${outCount})</span><button class="insp-btn" data-clear="output">DEL</button></div>`;
                }
                document.getElementById('insp-content').innerHTML = html;
                lastInspectorStructure = structure;
            } else {
                // Just update the values
                let status = "OPERATIONAL", statusColor = "#4caf50";
                if (b.outputBuffer && b.outputCount >= 5) { status = "OUTPUT FULL"; statusColor = "#ffd700"; }
                else if (b.type.id.includes('press') && b.inventory[ITEM.PLASTIC] === 0) { status = "NO PLASTIC"; statusColor = "#f44336"; }
                else if (b.type.id.includes('press') && b.moldLife <= 0 && b.inventory[ITEM.MOLD] === 0) { status = "NO MOLD"; statusColor = "#f44336"; }

                let statusEl = document.getElementById('insp-status');
                if (statusEl) {
                    statusEl.textContent = status;
                    statusEl.style.color = statusColor;
                }

                for (let k of inventoryKeys) {
                    let el = document.getElementById(`insp-${k}`);
                    if (el) el.textContent = `${k.toUpperCase()}: ${b.inventory[k]}`;
                }
                if (hasOutput) {
                    let el = document.getElementById('insp-output');
                    if (el) {
                        let outType = b.outputBuffer ? b.outputBuffer.toUpperCase() : 'NONE';
                        let outCount = b.outputCount || 0;
                        el.textContent = `OUT: ${outType} (x${outCount})`;
                    }
                }
            }
        }

        function updateUI() {
            document.getElementById('moneyDisplay').innerText = `$${money.toLocaleString()}`;
            document.getElementById('levelDisplay').innerText = level;
            let nextReq = LEVELS[level + 1];
            document.getElementById('nextUnlockDisplay').innerText = nextReq ? `${nextReq.reqParts} PARTS` : "MAX";
        }
        function showNotification(msg) {
            let n = document.getElementById('notification');
            n.innerText = msg; n.style.opacity = 1;
            setTimeout(()=>n.style.opacity=0, 2000);
        }

        let selectedArm = null;

        function openArmConfig(building) {
            selectedArm = building;
            const modal = document.getElementById('arm-config');
            const filterSection = document.getElementById('filter-section');
            const directionSection = document.getElementById('direction-section');

            // Show/hide sections based on arm capabilities
            filterSection.style.display = building.type.canFilter ? 'block' : 'none';
            directionSection.style.display = building.type.canDirectDeliver ? 'block' : 'none';

            modal.style.display = 'block';

            // Setup FILTER section
            if (building.type.canFilter) {
                const filterButtons = {
                    'filter-all': null,
                    'filter-plastic': ITEM.PLASTIC,
                    'filter-steel': ITEM.STEEL,
                    'filter-mold': ITEM.MOLD,
                    'filter-mold_quad': ITEM.MOLD_QUAD,
                    'filter-part': ITEM.PART
                };

                Object.entries(filterButtons).forEach(([btnId, itemType]) => {
                    const btn = document.getElementById(btnId);
                    // Reset styles
                    btn.style.border = '2px solid #444';
                    btn.style.background = '';

                    // Highlight current filter
                    if (building.filter === itemType) {
                        btn.style.border = '3px solid var(--usa-red)';
                        btn.style.background = 'rgba(220, 53, 69, 0.2)';
                    }

                    // Set click handler
                    btn.onclick = () => setArmFilter(itemType);
                });
            }

            // Setup DIRECTION section
            if (building.type.canDirectDeliver) {
                const pickupDir = (building.rot + 2) % 4;
                const currentDir = building.deliverDir;

                // Map buttons to actual direction constants: 0=RIGHT, 1=DOWN, 2=LEFT, 3=UP
                const dirButtons = [
                    document.getElementById('dir-right'),  // dir=0 = RIGHT
                    document.getElementById('dir-down'),   // dir=1 = DOWN
                    document.getElementById('dir-left'),   // dir=2 = LEFT
                    document.getElementById('dir-up')      // dir=3 = UP
                ];

                dirButtons.forEach((btn, dir) => {
                    // Reset styles
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.border = '2px solid #444';
                    btn.style.background = '';

                    // Disable pickup direction
                    if (dir === pickupDir) {
                        btn.disabled = true;
                        btn.style.opacity = '0.3';
                        btn.style.cursor = 'not-allowed';
                    }

                    // Highlight current delivery direction
                    if (dir === currentDir) {
                        btn.style.border = '3px solid var(--usa-red)';
                        btn.style.background = 'rgba(220, 53, 69, 0.2)';
                    }

                    // Set click handler
                    btn.onclick = () => setArmDirection(dir);
                });
            }
        }

        function setArmFilter(itemType) {
            if (selectedArm) {
                selectedArm.filter = itemType;
                const filterName = itemType ? itemType.toUpperCase() : 'ALL';
                showNotification(`ARM FILTER: ${filterName}`);
                // Update button highlighting
                openArmConfig(selectedArm);
            }
        }

        function setArmDirection(dir) {
            if (selectedArm) {
                selectedArm.deliverDir = dir;
                const dirNames = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
                showNotification(`ARM DIRECTION: ${dirNames[dir]}`);
                // Update button highlighting
                openArmConfig(selectedArm);
            }
        }

        function closeArmConfig() {
            selectedArm = null;
            document.getElementById('arm-config').style.display = 'none';
        }

        function populateVictoryReport() {
            // DEBUG: Log all values
            console.log('=== VICTORY REPORT DEBUG ===');
            console.log('lifetimeRevenue:', lifetimeRevenue);
            console.log('totalPlasticUsed:', totalPlasticUsed);
            console.log('totalSteelUsed:', totalSteelUsed);
            console.log('totalMoldsMade:', totalMoldsMade);
            console.log('partsSoldTotal:', partsSoldTotal);
            console.log('startTime:', startTime);
            console.log('Date.now():', Date.now());
            console.log('elapsedSec:', (Date.now() - startTime) / 1000);

            // Populate Report Stats
             document.getElementById('repRevenue').innerText = `$${lifetimeRevenue.toLocaleString()}`;
             document.getElementById('repTime').innerText = document.getElementById('timeDisplay').innerText;

             // Calculate Peak Rate from metrics history
             let maxRate = 0;
             metrics.history.forEach(m => {
                 let rate = m.part * 60;
                 if(rate > maxRate) maxRate = rate;
             });
             document.getElementById('repPeak').innerText = `${maxRate} PPM`;

             document.getElementById('repPlastic').innerText = totalPlasticUsed.toLocaleString();
             document.getElementById('repSteel').innerText = totalSteelUsed.toLocaleString();
             document.getElementById('repMolds').innerText = totalMoldsMade.toLocaleString();
             document.getElementById('repParts').innerText = partsSoldTotal.toLocaleString();

             // Calculate Grade
             let elapsedSec = (Date.now() - startTime) / 1000;
             let grade = 'F';
             if(elapsedSec < 900) grade = 'S'; // 15 mins
             else if(elapsedSec < 1500) grade = 'A'; // 25 mins
             else if(elapsedSec < 2100) grade = 'B'; // 35 mins
             else if(elapsedSec < 2700) grade = 'C'; // 45 mins
             else if(elapsedSec < 3300) grade = 'D'; // 55 mins
             // else F (65+ mins)
             console.log('Final grade:', grade);
             document.getElementById('gradeStamp').innerText = grade;

             // Date
             let d = new Date();
             document.getElementById('reportDate').innerText = d.toLocaleDateString().toUpperCase();
        }

        function endGame() {
             document.getElementById('modal-overlay').style.display = 'flex';
             document.getElementById('intro-modal').style.display = 'none';
             document.getElementById('win-modal').style.display = 'flex';
             gameRunning = false;

             populateVictoryReport();
        }

        function drawGraphs() {
            function drawBezier(ctx, data, color, maxVal) {
                if (data.length < 2) return;
                ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
                let w = ctx.canvas.width, h = ctx.canvas.height;
                let step = w / 60;
                let startY = h - (data[0] / maxVal) * h;
                ctx.moveTo(0, startY);
                for (let i = 0; i < data.length - 1; i++) {
                    let x1 = i * step, y1 = h - (data[i] / maxVal) * h;
                    let x2 = (i + 1) * step, y2 = h - (data[i + 1] / maxVal) * h;
                    let mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
                    ctx.quadraticCurveTo(x1, y1, mx, my);
                }
                ctx.stroke();
                ctx.shadowBlur = 4; ctx.shadowColor = color; ctx.stroke(); ctx.shadowBlur = 0;
            }

            let plastics = metrics.history.map(m => m.plastic * 60);
            let parts = metrics.history.map(m => m.part * 60);
            let dollars = metrics.history.map(m => m.dollars * 60);
            let currentMax = Math.max(...plastics, ...parts, 10);
            let scale = Math.ceil(currentMax / 10) * 10;

            let dollarsMax = Math.max(...dollars, 10);
            let dollarsScale = Math.ceil(dollarsMax / 10) * 10;

            [gResCtx, gProdCtx, gRevCtx].forEach(c => {
                c.fillStyle = '#051005'; c.fillRect(0,0,240,100);
                c.strokeStyle = '#0f200f'; c.beginPath();
                for(let i=0;i<240;i+=20) { c.moveTo(i,0); c.lineTo(i,100); }
                for(let i=0;i<100;i+=20) { c.moveTo(0,i); c.lineTo(240,i); }
                c.stroke();
            });

            // Draw graph lines first
            drawBezier(gResCtx, plastics, C_PLASTIC, scale);
            drawBezier(gProdCtx, parts, C_PART, scale);
            drawBezier(gRevCtx, dollars, '#00ff00', dollarsScale);

            // Draw scale labels on top so they're not obscured
            [gResCtx, gProdCtx].forEach(c => {
                c.font = '8px monospace';
                // Draw dark background behind text for contrast
                c.fillStyle = '#051005';
                c.fillRect(0, 2, 25, 10);
                c.fillRect(0, 47, 25, 10);
                // Draw text
                c.fillStyle = '#00ff00';
                c.fillText(scale, 2, 10);
                c.fillText(scale/2, 2, 55);
            });

            // Draw scale labels for revenue graph
            gRevCtx.font = '8px monospace';
            // Draw dark background behind text for contrast
            gRevCtx.fillStyle = '#051005';
            gRevCtx.fillRect(0, 2, 30, 10);
            gRevCtx.fillRect(0, 47, 30, 10);
            // Draw text
            gRevCtx.fillStyle = '#00ff00';
            gRevCtx.fillText(dollarsScale, 2, 10);
            gRevCtx.fillText(dollarsScale/2, 2, 55);
        }

        // --- Drawing ---
        function draw() {
            ctx.fillStyle = '#1e2430'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#263238'; ctx.lineWidth = 1; ctx.beginPath();
            for(let x=0; x<=GRID_W; x++) { ctx.moveTo(x*TILE_SIZE, 0); ctx.lineTo(x*TILE_SIZE, GRID_H*TILE_SIZE); }
            for(let y=0; y<=GRID_H; y++) { ctx.moveTo(0, y*TILE_SIZE); ctx.lineTo(GRID_W*TILE_SIZE, y*TILE_SIZE); }
            ctx.stroke();

            for (let b of buildings) drawBuilding(b);
            for (let i of items) drawItem(i);
            if (gameRunning && mouseGridPos.x >= 0) drawGhost();
            if (inspectedBuilding) {
                ctx.strokeStyle = '#ff0'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                ctx.strokeRect(inspectedBuilding.x * TILE_SIZE, inspectedBuilding.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.setLineDash([]);
            }
            requestAnimationFrame(draw);
        }

        function drawBuilding(b) {
            let cx = b.x * TILE_SIZE + TILE_SIZE/2;
            let cy = b.y * TILE_SIZE + TILE_SIZE/2;
            ctx.save(); ctx.translate(cx, cy);
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-16, -16, 36, 36); 
            ctx.fillStyle = b.type.color; ctx.fillRect(-18, -18, 36, 36);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.strokeRect(-18, -18, 36, 36);
            ctx.rotate(b.rot * Math.PI/2);

            if (b.type.isArm) {
                ctx.fillStyle = '#222'; ctx.fillRect(-10, -10, 20, 20);

                // Calculate target angle based on delivery direction
                let targetAngle = 0; // default: forward
                if (b.type.canDirectDeliver) {
                    let dirDiff = (b.deliverDir - b.rot + 4) % 4;
                    if (dirDiff === 1) targetAngle = Math.PI / 2; // right (90¬∞)
                    else if (dirDiff === 3) targetAngle = -Math.PI / 2; // left (-90¬∞)
                    // dirDiff === 0 stays at 0 (forward)
                }

                // Swing from -œÄ (behind) to targetAngle (delivery direction)
                let angleOffset = -Math.PI + b.armAnim * (targetAngle + Math.PI);
                ctx.rotate(angleOffset);
                ctx.fillStyle = b.type.color; ctx.fillRect(0, -5, 24, 10);
                ctx.fillStyle = '#ccc'; ctx.fillRect(22, -6, 6, 12);
                if (b.heldItem) {
                    ctx.save(); ctx.translate(24, 0); ctx.rotate(-(b.rot*Math.PI/2 + angleOffset));
                    drawItemShape(ctx, b.heldItem); ctx.restore();
                }
            } else if (b.type.id.includes('belt')) {
                // Horizontal Belt Body (aligned with Right arrow)
                ctx.fillStyle = '#222'; 
                ctx.fillRect(-16, -10, 32, 20); 
                
                // Animation offset moving Right (positive X)
                let offset = (Date.now() / 1000 * b.type.transportSpeed * 200) % 8; 
                
                // Draw tread pattern (Vertical lines moving Right)
                ctx.fillStyle = '#1a1a1a';
                for(let i=-16; i<16; i+=8) {
                    let x = i + offset;
                    if(x > 16) x -= 32;
                    ctx.fillRect(x, -8, 2, 16); 
                }
                
                ctx.fillStyle = b.type.id === 'belt_fast' ? '#d32f2f' : '#607d8b';
                ctx.beginPath(); ctx.moveTo(-6,-6); ctx.lineTo(0,0); ctx.lineTo(-6,6); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(6,0); ctx.lineTo(0,6); ctx.stroke();
            } else {
                ctx.rotate(-b.rot * Math.PI/2);
                ctx.fillStyle = '#fff'; ctx.font = '16px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(b.type.icon, 0, 0);
                if (b.outputBuffer) {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
                    if(b.outputCount > 1) {
                        ctx.fillStyle='#fff'; ctx.font='9px monospace';
                        ctx.fillText(b.outputCount, 8, -8);
                    }
                    drawItemShape(ctx, b.outputBuffer);
                }
                if ((b.type.id.includes('cnc') || b.type.id.includes('press')) && b.timer > 0) {
                     ctx.fillStyle = '#000'; ctx.fillRect(-18,16,36,6); 
                     ctx.fillStyle = '#39ff14'; ctx.fillRect(-18,16,36*(b.timer/b.type.recipe.time),6); 
                }
                
                // LED Status Lights
                // Position: Bottom Right (relative to center un-rotated)
                // We are unrotated at this point in the stack due to the ctx.rotate above
                let ledX = 14, ledY = 14;
                
                if (b.type.id === 'bin') {
                    // Bin: Flash Green if just sold
                    if (Date.now() - b.lastSoldTime < 200) {
                        ctx.fillStyle = '#39ff14';
                        ctx.shadowBlur = 5; ctx.shadowColor = '#39ff14';
                        ctx.beginPath(); ctx.arc(ledX, ledY, 3, 0, Math.PI*2); ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                } else {
                    let ledColor = '#333'; // Off/Dim
                    
                    // Logic Priority: Red (Error) -> Yellow (Full) -> Green (Working)
                    let error = false;
                    let warning = false;
                    let working = (b.timer > 0);

                    // Error Checks
                    if (b.type.id.includes('press')) {
                        if (b.moldLife <= 0 && b.inventory[ITEM.MOLD] === 0 && b.inventory[ITEM.MOLD_QUAD] === 0) error = true;
                        else if (b.inventory[ITEM.PLASTIC] === 0 && b.moldLife > 0) error = true; 
                    } else if (b.type.id.includes('cnc') && b.inventory[ITEM.STEEL] === 0) {
                        error = true;
                    }

                    // Warning Check
                    // Sources always hold 1, mega machines (CNC/PRESS) hold 5, regular machines hold 1
                    let threshold = b.type.output ? 1 : (b.type.id.includes('mega') ? 5 : 1);
                    if (b.outputBuffer && b.outputCount >= threshold) warning = true;

                    // Blinking Logic
                    let blinkOn = Math.floor(Date.now() / 300) % 2 === 0;

                    if (error) {
                        ledColor = blinkOn ? '#ff0000' : '#550000';
                    } else if (warning) {
                        ledColor = blinkOn ? '#ffff00' : '#555500';
                    } else if (working) {
                        ledColor = '#39ff14';
                    }

                    ctx.fillStyle = ledColor;
                    if (ledColor === '#39ff14' || (blinkOn && (error || warning))) {
                        ctx.shadowBlur = 5; ctx.shadowColor = ledColor;
                    }
                    ctx.beginPath(); ctx.arc(ledX, ledY, 3, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            ctx.restore();
        }

        function drawItem(i) {
            let cx = (i.x * TILE_SIZE) + (TILE_SIZE/2), cy = (i.y * TILE_SIZE) + (TILE_SIZE/2);
            let dir = i.exitDir; if (dir === null) dir = i.sourceDir !== null ? (i.sourceDir + 2) % 4 : 0; 
            
            let drawX = cx, drawY = cy;
            
            if (i.progress < 0.5) {
                let sdx=0, sdy=0;
                if(i.sourceDir===0) sdx=1; if(i.sourceDir===1) sdy=1; if(i.sourceDir===2) sdx=-1; if(i.sourceDir===3) sdy=-1;
                let t = (0.5 - i.progress) * 2; 
                drawX = cx + sdx * t * (TILE_SIZE/2);
                drawY = cy + sdy * t * (TILE_SIZE/2);
            } else {
                let edx=0, edy=0;
                if(dir===0) edx=1; if(dir===1) edy=1; if(dir===2) edx=-1; if(dir===3) edy=-1;
                let t = (i.progress - 0.5) * 2;
                drawX = cx + edx * t * (TILE_SIZE/2);
                drawY = cy + edy * t * (TILE_SIZE/2);
            }
            
            ctx.save(); ctx.translate(drawX, drawY); drawItemShape(ctx, i.type); ctx.restore();
        }

        function drawItemShape(ctx, type) {
            if (type === ITEM.PLASTIC) { 
                ctx.fillStyle = C_PLASTIC; ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
            } else if (type === ITEM.PART) {
                ctx.fillStyle = C_PART; ctx.beginPath();
                for(let i=0;i<5;i++) {
                    ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*8, -Math.sin((18+i*72)/180*Math.PI)*8);
                    ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*3, -Math.sin((54+i*72)/180*Math.PI)*3);
                }
                ctx.fill();
            } else if (type === ITEM.MOLD_QUAD) {
                ctx.fillStyle = '#004d40'; ctx.fillRect(-7,-7,14,14); 
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(-3,-3,1.5,0,Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(3,-3,1.5,0,Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(-3,3,1.5,0,Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(3,3,1.5,0,Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle = (type === ITEM.MOLD) ? C_MOLD : C_STEEL;
                ctx.fillRect(-6,-6,12,12);
            }
        }

        function drawGhost() {
            let b = Object.values(BUILDINGS).find(b => b.id === selectedTool);
            if (!b) return;
            let cx = mouseGridPos.x * TILE_SIZE + TILE_SIZE/2;
            let cy = mouseGridPos.y * TILE_SIZE + TILE_SIZE/2;
            
            ctx.save(); ctx.translate(cx, cy);
            
            ctx.save();
            ctx.rotate(rotation * Math.PI / 2);
            let s = 1 + Math.sin(Date.now()/200)*0.1;
            ctx.scale(s, s);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.beginPath(); ctx.moveTo(10, -8); ctx.lineTo(22, 0); ctx.lineTo(10, 8); ctx.fill();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; ctx.beginPath(); ctx.arc(-15, 0, 4, 0, Math.PI*2); ctx.fill();
            ctx.restore();

            ctx.globalAlpha = 0.5;
            ctx.fillStyle = b.color; ctx.fillRect(-18,-18,36,36);
            ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.strokeRect(-18,-18,36,36);
            ctx.restore();
        }

        window.onload = init;

        // ===== FIREWORKS ANIMATION =====
        const fireworksCanvas = document.getElementById('fireworksCanvas');
        const fwCtx = fireworksCanvas.getContext('2d');

        function resizeFireworksCanvas() {
            fireworksCanvas.width = fireworksCanvas.offsetWidth;
            fireworksCanvas.height = fireworksCanvas.offsetHeight;
        }
        resizeFireworksCanvas();
        window.addEventListener('resize', resizeFireworksCanvas);

        const COLORS = ['#B22234', '#FFFFFF', '#3C3B6E']; // USA Red, White, Blue

        class Firework {
            constructor() {
                this.x = Math.random() * fireworksCanvas.width;
                this.y = fireworksCanvas.height;
                this.targetX = this.x + (Math.random() - 0.5) * 200;
                this.targetY = Math.random() * fireworksCanvas.height * 0.4 + 50;
                this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
                this.speed = Math.random() * 2 + 3;
                this.size = Math.random() * 0.7 + 0.5; // 0.5 to 1.2
                this.trail = [];
                this.exploded = false;
                this.particles = [];
            }

            update() {
                if (!this.exploded) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.speed) {
                        this.explode();
                    } else {
                        this.trail.push({ x: this.x, y: this.y });
                        if (this.trail.length > 10) this.trail.shift();

                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                } else {
                    this.particles.forEach(p => p.update());
                    this.particles = this.particles.filter(p => p.alpha > 0);
                }
            }

            explode() {
                this.exploded = true;
                const particleCount = (Math.random() * 50 + 80) * this.size;
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push(new Particle(this.x, this.y, this.color, this.size));
                }
            }

            draw() {
                if (!this.exploded) {
                    // Draw trail
                    this.trail.forEach((pos, i) => {
                        fwCtx.beginPath();
                        fwCtx.arc(pos.x, pos.y, 1.5, 0, Math.PI * 2);
                        fwCtx.fillStyle = this.color;
                        fwCtx.globalAlpha = i / this.trail.length * 0.3;
                        fwCtx.fill();
                    });

                    // Draw firework
                    fwCtx.globalAlpha = 0.6;
                    fwCtx.beginPath();
                    fwCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                    fwCtx.fillStyle = this.color;
                    fwCtx.fill();
                } else {
                    this.particles.forEach(p => p.draw());
                }
            }

            isDone() {
                return this.exploded && this.particles.length === 0;
            }
        }

        class Particle {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 3 + 1.5) * size;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.alpha = 0.6;
                this.gravity = 0.1;
                this.friction = 0.98;
            }

            update() {
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= 0.015;
            }

            draw() {
                fwCtx.globalAlpha = this.alpha;
                fwCtx.beginPath();
                fwCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                fwCtx.fillStyle = this.color;
                fwCtx.fill();
            }
        }

        let fireworks = [];
        let lastFireworkTime = 0;

        function animateFireworks(timestamp) {
            fwCtx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);

            // Spawn new fireworks randomly
            if (timestamp - lastFireworkTime > Math.random() * 1200 + 800) {
                fireworks.push(new Firework());
                lastFireworkTime = timestamp;
            }

            // Update and draw fireworks
            fireworks.forEach(fw => {
                fw.update();
                fw.draw();
            });

            // Remove finished fireworks
            fireworks = fireworks.filter(fw => !fw.isDone());

            requestAnimationFrame(animateFireworks);
        }

        requestAnimationFrame(animateFireworks);
    </script>

</body></html>